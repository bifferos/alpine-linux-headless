#!/usr/bin/env python3
"""
    This utility creates an Alpine Linux overlay tarball inside an ISO to bootstrap automated headless
    installs.

    Requires:
    - python3
    - mkisofs ('brew install cdrtools' on Macos)
    - Pub/priv keypair in ~/.ssh 

    Usage example:
    ./build_alpine_overlay.py --hostname foo --iso foo_apkovl.iso

    Next create a VM with two CD-ROM ISOs connected:
    - alpine-standard-3.23.2-x86_64.iso
    - foo_apkovl.iso

    The VM will then boot from the install ISO, which in turn runs code to find the akpovl ISO, extracts it
    and runs the installer automatically.  The VM will power off when complete.
"""

import os
import argparse
import sys
import tarfile
import io
from pathlib import Path
from subprocess import run, CalledProcessError
import shutil
from io import StringIO


DEFAULT_TARBALL = "alpine.apkovl.tar.gz"
DEFAULT_ISO = "apkovl.iso"
DEFAULT_DISK = "/dev/sda"
DEFAULT_TIMEZONE = "GMT"
DEFAULT_KEYMAP = "us us"


# OpenRC service template for unattended setup-alpine
# Placed in the overlay tarball at /etc/init.d/autosetup
AUTOS_SETUP_TEMPLATE = '''#!/sbin/openrc-run
name="Autosetup Alpine"
description="Run unattended setup-alpine on first boot"

depend() {
    need sysfs devfs mdev localmount modloop
    after modules bootmisc
}

start() {
    if [ -f /root/.autosetup.done ]; then
        einfo "Autosetup already done"
        return 0
    fi
    export ERASE_DISKS="%(disk)s"
    einfo "Running setup-alpine"
    setup-alpine -e -f /root/answers || return 1
    touch /root/.autosetup.done
    einfo "Autosetup complete"
    poweroff
}
'''


# setup-alpine answerfile template
# Placed in the overlay tarball at /root/answers
ANSWERS_TEMPLATE = '''# setup-alpine answerfile (autogenerated)
KEYMAPOPTS="%(keymap)s"
HOSTNAMEOPTS=%(hostname)s
DEVDOPTS=%(devdopts)s
INTERFACESOPTS="%(interfaces)s\n"
DNSOPTS=none
TIMEZONEOPTS="%(timezone)s"
PROXYOPTS=none
APKREPOSOPTS="-1 -c"
NTPOPTS=none
SSHDOPTS=openssh
# Skip creating a non-root user during unattended install
USEROPTS=none
# Disk configuration: sys mode on stated disk, no swap
DISKOPTS="-m sys -s 0 %(disk)s"
'''


# default interfaces content used by INTERFACESOPTS
INTERFACES_DHCP = '''auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
'''


HOME_DIR = Path.home()
SSH_DIR = HOME_DIR / ".ssh"

# Location in ~/.ssh to look for public keys to include in root's authorized_keys
# It's almost certainly safe to leave this list as-is but if you only want specific keys
# to be included, modify this list accordingly, and if it misses your key name, add it.
PUBLIC_KEYS = [
        SSH_DIR / "id_ed25519.pub",
        SSH_DIR / "id_rsa.pub",
        SSH_DIR / "id_ecdsa.pub",
        SSH_DIR / "id_dsa.pub",
        # security key variants if present
        SSH_DIR / "id_ed25519_sk.pub",
        SSH_DIR / "id_ecdsa_sk.pub",
    ]


class OverlayTar:
    def __init__(self, out_path: str):
        self.out_path = out_path
        self.added: set[str] = set()
        if os.path.exists(self.out_path):
            os.unlink(self.out_path)
        self.tf = tarfile.open(self.out_path, "w:gz")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        self.tf.close()

    def file(self, path: str, data: bytes | str, mode: int = 0o644):
        bin_data = data.encode()
        ti = tarfile.TarInfo(path)
        ti.size = len(bin_data)
        ti.mode = mode
        self.tf.addfile(ti, io.BytesIO(bin_data))

    def symlink(self, path: str, target: str):
        ti = tarfile.TarInfo(path)
        ti.type = tarfile.SYMTYPE
        ti.linkname = target
        ti.mode = 0o777
        self.tf.addfile(ti)

    def dir(self, path: str, mode: int = 0o755):
        ti = tarfile.TarInfo(path)
        ti.type = tarfile.DIRTYPE
        ti.mode = mode
        self.tf.addfile(ti)


def gather_authorized_keys() -> str:
    out = StringIO()
    for path in PUBLIC_KEYS:
        if path.exists():
            out.write(path.read_text().strip() + "\n")
    result = out.getvalue()
    if not result:
        raise RuntimeError("No SSH public keys found in ~/.ssh; authorized_keys is required")
    return result


def build_answers(args) -> str:
    # Populate defaults for template-driven fields if not provided
    if getattr(args, "interfaces", None) is None:
        args.interfaces = INTERFACES_DHCP
    if getattr(args, "devdopts", None) is None:
        args.devdopts = "mdev"

    return ANSWERS_TEMPLATE % vars(args)


def create_overlay_tar(args):
    autosetup_content = AUTOS_SETUP_TEMPLATE % vars(args)
    answers_txt = build_answers(args)

    with OverlayTar(args.tar) as ovl:
        # Minimal OpenRC autosetup service to run installer once
        ovl.file("etc/init.d/autosetup", autosetup_content, 0o755)
        # Enable autosetup at default runlevel (absolute target for busybox tar)
        ovl.dir("etc/runlevels/default/", 0o755)
        ovl.symlink("etc/runlevels/default/autosetup", "/etc/init.d/autosetup")
        # Ensure modloop is started during sysinit so /lib/modules is populated
        ovl.dir("etc/runlevels/sysinit/", 0o755)
        ovl.symlink("etc/runlevels/sysinit/modloop", "/etc/init.d/modloop")
        ovl.file("root/answers", answers_txt + "\n", 0o644)
        # Include SSH authorized_keys with secure perms (required)
        keys = gather_authorized_keys()
        ovl.dir("root/.ssh/", 0o700)
        ovl.file("root/.ssh/authorized_keys", keys, 0o600)


def build_iso(tarball_name: str, dest_iso: Path):
    mk = shutil.which("mkisofs")
    if not mk:
        raise ValueError("mkisofs not found")
    
    print(f"Creating ISO {dest_iso} with {tarball_name} at root...")
    try:
        run(["mkisofs", "-J", "-R", "-V", "APKOVL", "-o", str(dest_iso), f"{tarball_name}"], check=True)
    except CalledProcessError as e:
        print(f"mkisofs failed: {e}", file=sys.stderr)
        sys.exit(e.returncode)
    print(f"Created {dest_iso}")


def main():
    parser = argparse.ArgumentParser(description="Build headless Alpine overlay ISO (apkovl inside)")
    parser.add_argument("--hostname", required=True, help="Target hostname (required)")
    parser.add_argument("--tar", default=DEFAULT_TARBALL, help=f"tarball to create (default {DEFAULT_TARBALL})")
    parser.add_argument("--iso", default=DEFAULT_ISO, help=f"Output ISO path (default {DEFAULT_ISO})")
    parser.add_argument("--disk", default=DEFAULT_DISK, help=f"Install disk device (default {DEFAULT_DISK})")
    parser.add_argument("--timezone", default=DEFAULT_TIMEZONE, help=f"Timezone (default {DEFAULT_TIMEZONE})")
    parser.add_argument("--keymap", default=DEFAULT_KEYMAP, help=f"Keymap layout and variant (default {DEFAULT_KEYMAP})")
    parser.add_argument("--devdopts", default=None, help="Device manager option (e.g., 'mdev' or 'none'); default 'mdev' if omitted")
    parser.add_argument("--interfaces", default=None, help="Full /etc/network/interfaces content; default DHCP template if omitted")

    args = parser.parse_args()

    for file_name in [args.tar, args.iso]:
        if os.path.exists(file_name):
            print(f"Error: Output file {file_name} already exists; please remove it first.", file=sys.stderr)
            sys.exit(1)

    create_overlay_tar(args)
    build_iso(args.tar, args.iso)


if __name__ == "__main__":
    main()
